The Idea behind RestrictedPython
================================

Python is a `Turing-complete`_ programming language.
To offer a Python interface for users in web context is a potential security risk.
Web frameworks and Content Management Systems (CMS) want to offer their users a maximum extendability and that if possible through the web (TTW).
This also means to have permissions to add functionallity via a Python Script.

From the point of IT Secruity and safty there should be additional preventive measures taken to ensure integrity of the application and the server itself.

RestrictedPython did chose a way to define a safe subset of the python programming laguage.
This is a common approach for securing a programming language.
The `Ada Ravenscar profil`_ is a well known example of such an approach.

Defining a secure subset of the language did work, by restricting the `EBNF`_ elements and explicite allow or disallow language features.
As the power of a programming language came from its core library and implemented third party libraries, the call of those modules and methods must have an additional check and restricting.
RestricedPython did generally disallow calls to any library that is not explicit whitelisted.

As Python is a scripting language that is executed by an interpreter.
Any Python code that should be executed have to be explict checked before executing a generated byte code by the interpreter.

Python itself offers three methods that provide such a workflow:

* ``compile()`` which compiles source code to byte code
* ``exec`` / ``exec()`` which executes the byte code in the interpreter
* ``eval`` / ``eval()`` which executes a byte code expression

Therefore RestrictedPython offers a repacement for the python builtin function ``compile()`` (Python 2: https://docs.python.org/2/library/functions.html#compile / Python 3 https://docs.python.org/3/library/functions.html#compile).
This method is defined as following:

.. code:: Python

    compile(source, filename, mode [, flags [, dont_inherit]])

The definition of the ``compile()`` method has changed over time, but its relevant parameters ``source`` and ``mode`` still remains.

There are three valid string values for ``mode``:

* ``'exec'``
* ``'eval'``
* ``'single'``

For RestricedPython this ``compile()`` method is replaced by:

.. code:: Python

    compile_restriced(source, filename, mode [, flags [, dont_inherit]])

The primary parameter ``source`` has to be a ASCII or ``unicode`` string.
Both methods either returns compiled byte code that the interpreter could execute or throws errors if the provided source code is invalid.

As the ``compile`` and ``compile_restricted`` just compile the provided source code it is not enough to secure the system, as still all calls on the core library or third party libraries are available.

The two methods / Statements:

* ``exec`` / ``exec()``
* ``eval`` / ``eval()``

did have two parameters:

* globals
* locals

which are a reference to the Python builtins.

By modifing and restricting the avaliable moules, methods and constans from globals and locals we could limit the possible calls.

Additionally RestrictedPython offers a way to define a policy which allows to protect access on attributes and global elements.
This works by defining a restricted version of:

* ``print``
* ``getattr``
* ``setattr``
* ``import``

Also RestrictedPython provides three predifined, limited versions of Python's own ``__builtins__``:

* ``safe_builtins`` (by Guards.py)
* ``limited_builtins`` (by Limits.py), which provides restriced sequence types
* ``utilities_builtins`` (by Utilities.py), which provides access for standard modules math, random, string and for sets.

Additional there exists guard functions to make attributes of Python objects immutable --> ``full_write_guard`` (write and delete protected)

.. _Turing-complete: https://en.wikipedia.org/wiki/Turing_completeness
.. _Ada Ravenscar Profile: https://en.wikipedia.org/wiki/Ravenscar_profile
.. _EBNF: https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form
